# Leetcode每日一题

题目来源：[力扣(Leetcode)官网](https://leetcode-cn.com/)

`代码链接在题目描述后，也可以通过题号来寻找`

## [959 由斜杠划分区域](https://leetcode-cn.com/problems/regions-cut-by-slashes/)

在由 1 x 1 方格组成的 N x N 网格 grid 中，每个 1 x 1 方块由 /、\ 或空格构成。这些字符会将方块划分为一些共边的区域。（请注意，反斜杠字符是转义的，因此 \ 用 "\\" 表示）。返回区域的数目。

**提示：**

1. `1 <= grid.length == grid[0].length <= 30`
2. `grid[i][j]` 是 `'/'`、`'\'`、或 `' '`。

[959代码](959.py)

[官方视频题解](https://leetcode-cn.com/problems/regions-cut-by-slashes/solution/you-xie-gang-hua-fen-qu-yu-by-leetcode-67xb/)

考察知识点：[并查集](#并查集DisjointSets)

「斜杠」、「反斜杠」把单元格拆分成的 2 个三角形的形态，在做合并的时候需要分类讨论。根据「斜杠」、「反斜杠」分割的特点，我们把一个单元格分割成逻辑上的 4 个部分。

![](image/959_1.png)

我们须要遍历一次输入的二维网格 grid，在`单元格内`和`单元格间`进行合并。

* 单元格内：

如果是空格：合并 0、1、2、3；
如果是斜杠：合并 0、3，合并 1、2；
如果是反斜杠：合并 0、1，合并 2、3。

* 单元格间：

把每一个单元格拆分成 4 个小三角形以后，相邻的单元格须要合并，无须分类讨论。我们选择在遍历 grid 的每一个单元格的时候，分别`向右、向下`尝试合并。

<img src="image/959_2.png" style="zoom: 50%;" />

`复杂度分析`

时间复杂度：$O(N^2logN)$。

空间复杂度：$O(N^2)$。



另一种解法

![](image/959_3.png)

思路是如果斜杠的两个节点都在边缘这个集合里，那么它就闭合了，将空间一分为二。

## [1579. 保证图可完全遍历](https://leetcode-cn.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/)

Alice 和 Bob 共有一个无向图，其中包含 n 个节点和 3  种类型的边：

* 类型 1：只能由 Alice 遍历。

* 类型 2：只能由 Bob 遍历。

* 类型 3：Alice 和 Bob 都可以遍历。


给你一个数组 edges ，其中 edges[i] = [typei, ui, vi] 表示节点 ui 和 vi 之间存在类型为 typei 的双向边。请你在保证图仍能够被 Alice和 Bob 完全遍历的前提下，找出可以删除的最大边数。如果从任何节点开始，Alice 和 Bob 都可以到达所有其他节点，则认为图是可以完全遍历的。

返回可以删除的最大边数，如果 Alice 和 Bob 无法完全遍历图，则返回 -1 。



示例1：

![](image/1579_1.png)

> 输入：n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]
> 输出：2
> 解释：如果删除 [1,1,2] 和 [1,1,3] 这两条边，Alice 和 Bob 仍然可以完全遍历这个图。再删除任何其他的边都无法保证图可以完全遍历。所以可以删除的最大边数是 2 。

示例2：

![](image/1579_2.png)

> 输入：n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]
> 输出：0
> 解释：注意，删除任何一条边都会使 Alice 和 Bob 无法完全遍历这个图。

示例3：

![](image/1579_1.png)

> 输入：n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]]
> 输出：-1
> 解释：在当前图中，Alice 无法从其他节点到达节点 4 。类似地，Bob 也不能达到节点 1 。因此，图无法完全遍历。

提示：

* 1 <= n <= 10^5
* 1 <= edges.length <= min(10^5, 3 * n * (n-1) / 2)
* edges[i].length == 3
* 1 <= edges\[i\]\[0\] <= 3
* 1 <= edges\[i\]\[1\] < edges\[i\]\[2\] <= n
* 所有元组 (typei, ui, vi) 互不相同



考察知识点：[并查集](#并查集DisjointSets)

[官方解题思路](https://leetcode-cn.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/solution/bao-zheng-tu-ke-wan-quan-bian-li-by-leet-mtrw/)

`思路与算法`

我们称类型 1, 2, 31,2,3 的边分别为「Alice 独占边」「Bob 独占边」以及「公共边」。

首先我们需要思考什么样的图是可以被 Alice 和 Bob 完全遍历的。对于 Alice 而言，她可以经过的边是「Alice 独占边」以及「公共边」，由于她需要能够从任意节点到达任意节点，那么就说明：

当图中仅有「Alice 独占边」以及「公共边」时，整个图是连通的，即整个图只包含一个连通分量。

同理，对于 Bob 而言，当图中仅有「Bob 独占边」以及「公共边」时，整个图也要是连通的。



由于题目描述中希望我们`删除最多数目的边`，这`等价于保留最少数目的边`。换句话说，我们可以从一个仅包含n个节点（而没有边）的无向图开始，逐步添加边，使得满足上述的要求。

那么我们应该按照什么策略来添加边呢？直觉告诉我们，「公共边」的重要性大于「Alice 独占边」以及「Bob 独占边」，因为「公共边」是 Alice 和 Bob 都可以使用的，而他们各自的独占边却不能给对方使用。

「公共边」的重要性也是可以证明的：

> 对于一条连接了两个不同的连通分量的「公共边」而言，如果我们不保留这条公共边，那么 Alice 和 Bob 就无法往返这两个连通分量，即他们分别需要使用各自的独占边。因此，Alice 需要一条连接这两个连通分量的独占边，Bob 同样也需要一条连接这两个连通分量的独占边，那么一共需要两条边，这就严格不优于直接使用一条连接这两个连通分量的「公共边」了。

因此，我们可以遵从优先添加「公共边」的策略。

具体地，我们遍历每一条「公共边」，对于其连接的的两个节点：

* 如果这两个节点在同一个连通分量中，那么添加这条「公共边」是无意义的；

* 如果这两个节点不在同一个连通分量中，我们就可以（并且一定）添加这条「公共边」，然后合并这两个节点所在的连通分量。

这就提示了我们使用并查集来维护整个图的连通性，上述的策略只需要用到并查集的「查询」和「合并」这两个最基础的操作。

在处理完了所有的「公共边」之后，我们需要处理他们`各自的独占边`，而方法也与添加「公共边」类似。我们将当前的并查集复制一份，一份交给 Alice，一份交给 Bob。随后 Alice 不断地向并查集中添加「Alice 独占边」，Bob 不断地向并查集中添加「Bob 独占边」。在处理完了所有的独占边之后，如果这两个并查集都只包含一个连通分量，那么就说明 Alice 和 Bob 都可以遍历整个无向图。

`细节`

在使用并查集进行合并的过程中，我们每遇到一次失败的合并操作（即需要合并的两个点属于同一个连通分量），那么就说明当前这条边可以被删除，将答案增加 1。

## [1128. 等价多米诺骨牌对的数量](https://leetcode-cn.com/problems/number-of-equivalent-domino-pairs/)

给你一个由一些多米诺骨牌组成的列表 dominoes。

如果其中某一张多米诺骨牌可以通过旋转 0 度或 180 度得到另一张多米诺骨牌，我们就认为这两张牌是等价的。形式上，`dominoes[i] = [a, b]`和`dominoes[j] = [c, d]`等价的前提是 a=c 且 b=d，或是 a=d 且 b=c。在` 0 <= i < j < dominoes.length` 的前提下，找出满足`dominoes[i]`和`dominoes[j]`等价的骨牌对`(i, j)`的数量。

> 示例：
> 输入：dominoes = [[1,2],[2,1],[3,4],[5,6]]
> 输出：1

**提示：**

- `1 <= dominoes.length <= 40000`
- `1 <= dominoes[i][j] <= 9`

[1128代码](1128.py)

`解析`：

注意到每张牌都是二元组(x,y)，那么用10x+y就可以唯一确定，如果规定让小的为x，那么可以同时确定等价的多米诺骨牌。

接下来问题就是如何储存数量信息，可以使用`字典`，key为10x+y，value为个数。那么，我们最后的结果是要将大于1的value，进行$C_{value}^2$，然后相加。也可以使用`数组`

可以将value设为二元数组[i,j]，初次添加为[1,0]，然后每次更新都变为[i+1,i+j]，i是等价骨牌的数量，j是通过类似循环来计算$C_{value}^2$。也可以通过其他方式来计算。

`复杂度分析`

时间复杂度：$O(N)$。

空间复杂度：$O(1)$。因为实际上字典大小不会超过100。

## [724. 寻找数组的中心索引](https://leetcode-cn.com/problems/find-pivot-index/)

给定一个整数类型的数组 nums，请编写一个能够返回数组 “中心索引” 的方法。

我们是这样定义数组 中心索引 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。

如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。

> 示例1:
>
> 输入：
> nums = [1, 7, 3, 6, 5, 6]
> 输出：3
> 解释：
> 索引 3 (nums[3] = 6) 的左侧数之和 (1 + 7 + 3 = 11)，与右侧数之和 (5 + 6 = 11) 相等。
> 同时, 3 也是第一个符合要求的中心索引。
>
> 
>
> 示例2：
>
> 输入：
> nums = [1, 2, 3]
> 输出：-1
> 解释：
> 数组中不存在满足此条件的中心索引。

**提示**：

- `nums` 的长度范围为 `[0, 10000]`。
- 任何一个 `nums[i]` 将会是一个范围在 `[-1000, 1000]`的整数。



考察知识点：[前缀和](#前缀和)

`思路`

记数组的全部元素之和为total，当遍历到第 i 个元素时，设其左侧元素之和为sum，则其右侧元素之和为total-nums\[i\]-sum。左右元素相等即为2*sum+nums[i]=total。

当中心索引左侧或右侧没有元素时，即为零个项相加，这在数学上称作「空和」。在程序设计中我们约定「空和是零」。

`复杂度`:

- 时间复杂度：O(n)，其中 n为数组的长度。
- 空间复杂度：O(1)。



## [1631. 最小体力消耗路径](https://leetcode-cn.com/problems/path-with-minimum-effort/)

你准备参加一场远足活动。给你一个二维`rows x columns`的地图`heights`，其中`heights[row][col]` 表示格子 `(row, col)`的高度。一开始你在最左上角的格子`(0, 0)`，且你希望去最右下角的格子`(rows-1, columns-1)`（注意下标从 0 开始编号）。你每次可以往**上，下，左，右**四个方向之一移动，你想要找到耗费**体力**最小的一条路径。

一条路径耗费的**体力值**是路径上相邻格子之间**高度差绝对值**的**最大值**决定的。

请你返回从左上角走到右下角的最小**体力消耗值**。



示例1：

![](image/1631_1.png)

> 输入：heights = [[1,2,2],[3,8,2],[5,3,5]]
> 输出：2
> 解释：路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。
> 这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值为 3 。

示例2：

![](image/1631_2.png)

> 输入：heights = [[1,2,3],[3,8,4],[5,3,5]]
> 输出：1
> 解释：路径 [1,2,3,4,5] 的相邻格子差值绝对值最大为 1 ，比路径 [1,3,5,3,5] 更优。

示例3：

![](image/1631_3.png)

> 输入：heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]
> 输出：0
> 解释：上图所示路径不需要消耗任何体力。

**提示**：

* rows == heights.length
* columns == heights[i].length
* 1 <= rows, columns <= 100
* 1 <= heights\[i\]\[j\] <= 10^6



`思路`：

我们可以将本题抽象成如下的一个图论模型：

* 我们将地图中的每一个格子看成图中的一个节点；
* 我么将两个相邻（左右相邻或者上下相邻）的两个格子对应的节点之间连接一条无向边，边的权值为这两个格子的高度差的绝对值；
* 我们需要找到一条从左上角到右下角的最短路径，其中一条路径的长度定义为其经过的所有边权的最大值。

由于地图是二维的，我们需要给每个格子对应的节点赋予一个唯一的节点编号。如果地图的行数为 m，列数为 n，那么位置为(i, j)的格子对应的编号为 i*n+j，这样 ,mn个格子的编号一一对应着[0, mn)范围内的所有整数。当然，如果读者使用的语言支持对二元组进行哈希计算、作为下标访问等，则不需要这一步操作。



`方法一：二分查找`

我们可以将这个问题转化成一个「判定性」问题，即：

> 是否存在一条从左上角到右下角的路径，其经过的所有边权的最大值不超过 xx？

这个判定性问题解决起来并不复杂，我们只要从左上角开始进行`深度优先搜索`或者`广度优先搜索`，在搜索的过程中只允许经过边权不超过 x 的边，搜索结束后判断是否能到达右下角即可。

随着 x 的增大，原先可以经过的边仍然会被保留，因此如果当 x=x0时，我们可以从左上角到达右下角，那么当 x > x0时同样也可以可行的。因此我们可以使用二分查找的方法，找出满足要求的最小的那个 x 值，记为 x_ans，那么：

* 当 x < x_ans,我们无法从左上角到达右下角；

* 当 x >=x_ans,我们可以从左上角到达右下角。

由于格子的高度范围为 \[1, 10^6\]，因此我们可以 [0, 10^6-1] 的范围内对 x 进行二分查找。在每一步查找的过程中，我们使用进行深度优先搜索或者广度优先搜索判断是否可以从左上角到达右下角，并根据判定结果更新二分查找的左边界或右边界即可。

`复杂度分析`

* 时间复杂度：$O(mn \log C)$，其中m和n分别是地图的行数和列数，C是格子的最大高度，在本题中C不超过 10^6。我们需要进行$O(\log C)$次二分查找，每一步查找的过程中需要使用广度优先搜索，在O(mn)的时间判断是否可以从左上角到达右下角，因此总时间复杂度为$O(mn \log C)$。

* 空间复杂度：O(mn)，即为广度优先搜索中使用的队列需要的空间。



Python代码

>  定义一个set，放入符合条件的tuple(i,j)，如果(m-1,n-1)最后在set中，则x_ans小于mid。
>
> 使用q=collections.deque([0,0])，q.popleft()，set.add()



`方法二：并查集`

我们将这mn个节点放入并查集中，实时维护它们的连通性。

由于我们需要找到从左上角到右下角的最短路径，因此我们可以将图中的`所有边按照权值从小到大进行排序，并依次加入并查集中`。当我们加入一条权值为x的边之后，如果左上角和右下角从非连通状态变为连通状态，那么x即为答案。

所有边利用三元组来存储：`(node1,node2,h(node1,node2))`

```python
edges = []
for i in range(m):
    for j in range(n):
        here = i*n + j
        if i > 0:
            edges.append((here - n,here,abs(heights[i-1][j]-heights[i][j])))
        if j > 0:
            edges.append((here - 1,here,abs(heights[i][j-1]-heights[i][j])))
edges.sort(key = lambda e:e[2])
```



`复杂度分析`

* 时间复杂度$O(mn \log(mn))$，其中m和n分别是地图的行数和列数。图中的边数为O(mn)，因此排序的时间复杂度为$O(mn \log (mn))$并查集的时间复杂度为$O(mn \cdot \alpha(mn))$，其中$\alpha$为阿克曼函数的反函数。由于后者在渐进意义下小于前者，因此总时间复杂度为$O(mn \log(mn))$。
* 空间复杂度：O(mn)O(mn)，即为存储所有边以及并查集需要的空间。



## [778. 水位上升的泳池中游泳](https://leetcode-cn.com/problems/swim-in-rising-water/)

在一个 N x N 的坐标方格 grid 中，每一个方格的值 grid[i][j] 表示在位置 (i,j) 的平台高度。

现在开始下雨了。当时间为 t 时，此时雨水导致水池中任意位置的水位为 t 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。

你从坐标方格的左上平台 (0，0) 出发。最少耗时多久你才能到达坐标方格的右下平台 (N-1, N-1)？

> 示例 1:
>
> 输入: [[0,2],[1,3]]
> 输出: 3
> 解释:
> 时间为0时，你位于坐标方格的位置为 (0, 0)。
> 此时你不能游向任意方向，因为四个相邻方向平台的高度都大于当前时间为 0 时的水位。
>
> 等时间到达 3 时，你才可以游向平台 (1, 1). 因为此时的水位是 3，坐标方格中的平台没有比水位 3 更高的，所以你可以游向坐标方格中的任意位置
>
> 
>
>
> 示例2:
>
> 输入: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]
> 输出: 16
> 解释:
>  0  1  2  3  4
> 24 23 22 21  5
> 12 13 14 15 16
> 11 17 18 19 20
> 10  9  8  7  6
> 我们必须等到时间为 16，此时才能保证平台 (0, 0) 和 (4, 4) 是连通的

**提示**:

* 2 <= N <= 50.
* grid\[i\]\[j\] 是 [0, ..., N*N - 1] 的排列。



`思路`

注意题目中的重要信息：假定你可以 瞬间移动 无限距离，游动不耗时。当前这个问题就转换成为：找一个时刻 t，使得这个二维网格上数值 小于等于 t 的部分，存在一条从左上角到右下角的路径。即：经过了时间 t 以后，可以瞬间从左上角（坐标 [0, 0]）游到右下角（坐标 [N - 1, N - 1]）



关于连通性的问题，如果只问结果，不问具体怎么连起来的，还可以考虑使用[并查集](#并查集DisjointSets)

可以模拟下雨的过程，把网格抽象成一个`无权图`，每经过一个时刻，就`考虑此时和雨水高度相等的单元格`，考虑这个单元格的`上、下、左、右、四个方向`，并且`高度更低`的单元格，把它们在并查集中进行`合并`。在判断左上和右下是否连通。



`复杂度分析`：

* 时间复杂度：$O(N^2 \log N)$，其中N是方格的边长，计数排序$O(N^2)$，合并四周、检查起点和终点是否同属于一个连通分量$O(\log N^2)$，总的时间复杂度为$O(N^2 + N^2\log N^2) = O(N^2 + 2N^2\log N) = O(N^2 \log N)$
* 空间复杂度：$O(N^2)$，数组 index 的长度，并查集底层的长度均为$N^2$。



## [839. 相似字符串组](https://leetcode-cn.com/problems/similar-string-groups/)

如果交换字符串 X 中的两个不同位置的字母，使得它和字符串 Y 相等，那么称 X 和 Y 两个`字符串相似`。如果这两个字符串本身是相等的，那它们也是相似的。

例如，"tars" 和 "rats" 是相似的 (交换 0 与 2 的位置)； "rats" 和 "arts" 也是相似的，但是 "star" 不与 "tars"，"rats"，或 "arts" 相似。

总之，它们通过相似性形成了两个关联组：{"tars", "rats", "arts"} 和 {"star"}。注意，"tars" 和 "arts" 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。

给你一个字符串列表 strs。列表中的每个字符串都是 strs 中其它所有字符串的一个字母异位词。请问 strs 中有多少个`相似字符串组`？

> 示例 1：
>
> 输入：strs = ["tars","rats","arts","star"]
> 输出：2
>
> 
>
>
> 示例 2：
>
> 输入：strs = ["omv","ovm"]
> 输出：1

**提示**：

* 1 <= strs.length <= 100
* 1 <= strs[i].length <= 1000
* sum(strs[i].length) <= 2 * 104
* strs[i] 只包含小写字母。
* strs 中的所有单词都具有相同的长度，且是彼此的字母异位词。

**备注**：

>   字母异位词（anagram），一种把某个字符串的字母的位置（顺序）加以改换所形成的新词。



`思路`：

我们把每一个字符串看作点，字符串之间是否相似看作边，那么可以发现本题询问的是给定的图中`有多少连通分量`。于是可以想到使用[并查集](#并查集DisjointSets)维护节点间的连通性。

我们枚举给定序列中的任意一对字符串，检查其`是否具有相似性`，如果相似，那么我们就`将这对字符串相连`。

在实际代码中，我们可以首先判断当前这对字符串是否已经连通，如果没有连通，我们再检查它们是否具有相似性，可以优化一定的时间复杂度的常数。



**字符串相似函数**

```python
def isSimilar(self,x,y):
    num = 0
    for a,b in zip(x,y):
        if a != b:
            num += 1
        if num > 2:
            return False
    return True
```



**复杂度分析**：

* 时间复杂度：$O(n^2m + n \log n))$，其中 nn 是字符串的数量。我们需要$O(n^2)$地枚举任意一对字符串之间的关系，对于任意一对字符串，我们需要 O(m)的时间检查字符串是否相同。在最坏情况下我们需要对并查集执行O(n)次合并，合并的均摊时间复杂度$O(\log n)$。综上，总的时间复杂度为$O(n^2m + n \log n))$。
* 空间复杂度：O(n)，其中n是字符串的数量。并查集需要O(n)的空间。

## [888. 公平的糖果棒交换](https://leetcode-cn.com/problems/fair-candy-swap/)

爱丽丝和鲍勃有不同大小的糖果棒：A[i] 是爱丽丝拥有的第 i 根糖果棒的大小，B[j] 是鲍勃拥有的第 j 根糖果棒的大小。

因为他们是朋友，所以他们想交换一根糖果棒，这样交换后，他们都有相同的糖果总量。（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。）

返回一个整数数组 ans，其中 ans[0] 是爱丽丝必须交换的糖果棒的大小，ans[1] 是 Bob 必须交换的糖果棒的大小。如果有多个答案，你可以返回其中任何一个。保证答案存在。

> 示例 1：
>
> 输入：A = [1,1], B = [2,2]
> 输出：[1,2]
>
> 
>
> 示例 2：
>
> 输入：A = [1,2], B = [2,3]
> 输出：[1,2]
>
> 
>
> 示例 3：
>
> 输入：A = [2], B = [1,3]
> 输出：[2,3]
>
> 
>
> 示例 4：
>
> 输入：A = [1,2,5], B = [2,4]
> 输出：[5,4]

**提示**：

* 1 <= A.length <= 10000
* 1 <= B.length <= 10000
* 1 <= A[i] <= 100000
* 1 <= B[i] <= 100000
* 保证爱丽丝与鲍勃的糖果总量不同。
* 答案肯定存在。



记爱丽丝的糖果棒的总大小为$\textit{sumA}$，鲍勃的糖果棒的总大小为$\textit{sumB}$。设答案为{x,y}，即爱丽丝的大小为x的糖果棒与鲍勃的大小为y的糖果棒交换，则有如下等式：
$$
sumA - x + y = sumB -y + x \\
x = y + \frac{{sumA - sumB}}{2}
$$
对于B中任意一个数，只要A中对应公式存在相应的数，那么就找到了一组可行解。

为了快速查询 A*A* 中是否存在某个数，我们可以先将 A*A* 中的数字存入哈希表中。

```python
a = set(A)
if x in a:
    reutrn [x,y]
```



# Leetcode热题Hot100







# 知识点目录

## 算法

- 基础技巧：分治、二分、贪心
- 排序算法：快速排序、归并排序、计数排序
- 搜索算法：回溯、递归、深度优先遍历，广度优先遍历，二叉搜索树等
- 图论：最短路径、最小生成树
- 动态规划：背包问题、最长子序列

## 数据结构

- 数组与链表：单 / 双向链表
- 栈与队列
- 哈希表
- 堆：最大堆 ／ 最小堆
- 树与图：最近公共祖先、并查集
- 字符串：前缀树（字典树） ／ 后缀树





# 相关知识点

## 并查集DisjointSets

### 定义

并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。这一类问题近几年来反复出现在信息学的国际国内赛题中。

### 特点

并查集被很多OIer认为是最简洁而优雅的数据结构之一，主要用于解决一些**元素分组**的问题。它管理一系列**不相交的集合**，并支持两种操作：

- **合并**（Union）：把两个不相交的集合合并为一个集合。
- **查询**（Find）：查询两个元素是否在同一个集合中。

初始化每一个点都是一个连通域，类似下图：

![](image/DisjointSets_1.jpg)

由于支持这两种操作，一个不相交集也常被称为联合-查找数据结构（Union-find Data Structure）或合并-查找集合（Merge-find Set）。为了更加精确的定义这些方法，需要定义如何表示集合。一种常用的策略是为每个集合选定一个固定的元素，称为代表，以表示整个集合。接着，Find(x) 返回 x 所属集合的代表，而 Union 使用两个集合的代表作为参数。

### 应用：

#### 亲戚问题

>**题目背景**
>若某个家族人员过于庞大，要判断两个是否是亲戚，确实还很不容易，现在给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。
>**题目描述**
>规定：x和y是亲戚，y和z是亲戚，那么x和z也是亲戚。如果x,y是亲戚，那么x的亲戚都是y的亲戚，y的亲戚也都是x的亲戚。
>**输入格式**
>第一行：三个整数n,m,p，（n<=5000,m<=5000,p<=5000），分别表示有n个人，m个亲戚关系，询问p对亲戚关系。
>以下m行：每行两个数Mi，Mj，1<=Mi，Mj<=N，表示Mi和Mj具有亲戚关系。
>接下来p行：每行两个数Pi，Pj，询问Pi和Pj是否具有亲戚关系。
>**输出格式**
>P行，每行一个’Yes’或’No’。表示第i个询问的答案为“具有”或“不具有”亲戚关系。

建立模型，把所有人划分到若干个不相交的集合中，每个集合里的人彼此是亲戚。为了判断两个人是否为亲戚，只需看它们是否属于同一个集合即可。

#### 并查集的引入

并查集的重要思想在于，**用集合中的一个元素代表集合**。一个有趣的比喻，把集合比喻成**帮派**，而代表元素则是**帮主**。

这是一个**树**状的结构，要寻找集合的代表元素，只需要一层一层往上访问**父节点**（图中箭头所指的圆），直达树的**根节点**（图中橙色的圆）即可。根节点的父节点是它自己。

#### 并查集代码流程

* 初始化

假如有编号为1, 2, 3, ..., n的n个元素，我们用一个数组fa[]来存储每个元素的父节点（因为每个元素有且只有一个父节点，所以这是可行的）。一开始，我们先将它们的父节点设为自己。

* 查询find

我们用递归的写法实现对代表元素的查询：一层一层访问父节点，直至根节点（根节点的标志就是父节点是本身）。要判断两个元素是否属于同一个集合，只需要看它们的根节点是否相同即可。

* 合并union

合并操作也是很简单的，先找到两个集合的代表元素，然后将前者的父节点设为后者即可。

* 路径压缩

既然我们只关心一个元素对应的**根节点**，那我们希望每个元素到根节点的路径尽可能短，最好只需要一步。在查询的过程中，**把沿途的每个节点的父节点都设为根节点**即可。

### 核心API

#### find

```python
def find(self, x):
    while x != self.parent[x]:
        x = self.parent[x]
    return x
```

递归实现

```python
def find(self, x):
    if x != self.parent[x]:
        self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    return x
```

（这里进行了路径的压缩）

![](image/DisjointSets_2.jpg)

#### connected

直接利用上面实现好的 find 方法即可。如果两个节点的祖先相同，那么其就联通。

```python
def connected(self, p, q):
    return self.find(p) == self.find(q)
```

#### union

将其中一个节点挂到另外一个节点的祖先上，这样两者祖先就一样了。也就是说，两个节点联通了。

```python
def union(self, p, q):
    if self.connected(p, q): return
    self.parent[self.find(p)] = self.find(q)
```

### 不带权并查集

平时做题过程，遇到的更多的是不带权的并查集。相比于带权并查集， 其实现过程也更加简单。

#### 带路径压缩的代码模板

```python
class UnionFind:
    def __init__(self,n):
        self.parent = list(range(n))
        self.size = [1]*n
        self.cnt = n
    def find(self,x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
            return self.parent[x]
        return x

    def union(self,x,y):
        xroot = self.find(x)
        yroot = self.find(y)
        if xroot == yroot:
            return
        if self.size[xroot] < self.size[yroot]:
            xroot,yroot = yroot,xroot
        self.parent[yroot] = xroot
        self.size[xroot] += self.size[yroot]
        self.cnt -= 1
    def isConnected(self,x,y):
        return self.find(x) == self.find(y)
```

### 带权并查集

实际上并查集就是图结构，我们使用了哈希表来模拟这种图的关系。 而上面讲到的其实都是有向无权图，因此仅仅使用 parent 表示节点关系就可以了。而如果使用的是有向带权图呢？实际上除了维护 parent 这样的节点指向关系，我们还需要维护节点的权重，一个简单的想法是使用另外一个哈希表 weight 存储节点的权重关系。比如 `weight[a] = 1 表示 a 到其父节点的权重是 1`。

如果是带权的并查集，其查询过程的路径压缩以及合并过程会略有不同，因为我们不仅关心节点指向的变更，也关心权重如何更新。比如：

```
a    b
^    ^
|    |
|    |
x    y
```

如上表示的是 x 的父节点是 a，y 的父节点是 b，现在我需要将 x 和 y 进行合并。

```
a    b
^    ^
|    |
|    |
x -> y
```

假设 x 到 a 的权重是 w(xa)，y 到 b 的权重为 w(yb)，x 到 y 的权重是 w(xy)。合并之后会变成如图的样子：

```
a -> b
^    ^
|    |
|    |
x    y
```

那么 a 到 b 的权重应该被更新为什么呢？我们知道 w(xa) + w(ab) = w(xy) + w(yb)，也就是说 a 到 b 的权重 w(ab) = w(xy) + w(yb) - w(xa)。

当然上面关系式是加法，减法，取模还是乘法，除法等完全由题目决定，我这里只是举了一个例子。不管怎么样，这种运算一定需要满足**可传导性**。

#### 带路径压缩的代码模板

这里以加法型带权并查集为例，讲述一下代码应该如何书写。

```python
class UF:
    def __init__(self, M):
        # 初始化 parent，weight
        self.parent = {}
        self.weight = {}
        for i in range(M):
            self.parent[i] = i
            self.weight[i] = 0

   def find(self, x):
        if self.parent[x] != x:
            ancestor, w = self.find(self.parent[x])
            self.parent[x] = ancestor
            self.weight[x] += w
        return self.parent[x], self.weight[x]
    def union(self, p, q, dist):
        if self.connected(p, q): return
        leader_p, w_p = self.find(p)
        leader_q, w_q = self.find(q)
        self.parent[leader_p] = leader_q
        self.weight[leader_p] = dist + w_q - w_p
    def connected(self, p, q):
        return self.find(p)[0] == self.find(q)[0]
```

### 总结

如果题目有连通，等价的关系，那么你就可以考虑并查集，另外使用并查集的时候要注意路径压缩，否则随着树的高度增加复杂度会逐渐增大。

对于带权并查集实现起来比较复杂，主要是路径压缩和合并这块不一样，不过我们只要注意节点关系，画出如下的图：

```
a -> b
^    ^
|    |
|    |
x    y
```

就不难看出应该如何更新。

## 前缀和

什么是`前缀和`？

前缀和是一个数组的某项下标之前(包括此项元素)的所有数组元素的和

|            |                     定义式                      |                      递推式                       |
| :--------: | :---------------------------------------------: | :-----------------------------------------------: |
| 一维前缀和 |           $b[i]=\sum_{j=0}^{i} a[j]$            |                $b[i]=b[i-1]+a[i]$                 |
| 二维前缀和 | $b[x][y]=\sum_{i=0}^{x} \sum_{j=0}^{y} a[i][j]$ | $b[x][y]=b[x-1][y]+b[x][y-1]-b[x-1][y-1]+a[x][y]$ |

### 一维前缀和

根据上述表达式我们可以以`O(1)`求出`区间[i,j]的区间和 `

```python
# 建立	pre[i]是i及之前nums之和
pre = [0]
for num in nums:
    pre.append(pre[-1] + num)
pre = pre[1:]
#  使用，等价于 nums[i] + nums[i + 1] + ... + nums[j]
pre[j] - pre[i-1] 
```

### 二维前缀和

```python
m,n = len(matrix), len(matrix[0])
# 建立
pre = [[0 for _ in range(n + 1)] for _ in range(m + 1)]

for i in range(1, m+1):
    for j in range(1, n+1):
        pre[i][j] = pre[i-1][j]+ pre[i][j-1] - pre[i-1][j-1] + matrix[i-1][j-1]
pre = pre[1:][1:]
# 使用，等价于以(x1,y1)为矩阵左上角以(x2,y2)为矩阵右下角的所有格子的和
# x,y从0起始
pre[x2][y2] + pre[x1-1][y1-1] - pre[x1-1][y2] - pre[x2][y2-1]
```

